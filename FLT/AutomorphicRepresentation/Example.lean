import Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing
import Mathlib.Tactic.Peel
/-

# Example of a space of automorphic forms

-/

/-- We define the profinite completion of ‚Ñ§ explicitly as compatible elements of ‚Ñ§/N‚Ñ§ for
all positive integers `N`. We declare it as a subring of `‚àè_{N ‚â• 1} (‚Ñ§/N‚Ñ§)`, and then promote it
to a type. -/
def ZHat : Type := {
  carrier := { f : Œ† M : ‚Ñï+, ZMod M | ‚àÄ (D N : ‚Ñï+) (h : (D : ‚Ñï) ‚à£ N),
    ZMod.castHom h (ZMod D) (f N) = f D },
  zero_mem' := by simp
  neg_mem' := fun {x} hx => by
    simp only [ZMod.castHom_apply, Set.mem_setOf_eq, Pi.neg_apply] at *
    peel hx with D N hD hx
    rw [ZMod.cast_neg hD, hx]
  add_mem' := fun {a b} ha hb => by
    simp only [ZMod.castHom_apply, Set.mem_setOf_eq, Pi.add_apply] at *
    intro D N hD
    rw [ZMod.cast_add hD, ha _ _ hD, hb _ _ hD]
  one_mem' := by
    simp only [ZMod.castHom_apply, Set.mem_setOf_eq, Pi.one_apply]
    intro D N hD
    rw [ZMod.cast_one hD]
  mul_mem' := fun {a b} ha hb => by
    simp only [ZMod.castHom_apply, Set.mem_setOf_eq, Pi.mul_apply] at *
    intro D N hD
    rw [ZMod.cast_mul hD, ha _ _ hD, hb _ _ hD]
  : Subring (Œ† n : ‚Ñï+, ZMod n)}
deriving CommRing

namespace ZHat

instance : DFunLike ZHat ‚Ñï+ (fun (N : ‚Ñï+) ‚Ü¶ ZMod N) where
  coe z := z.1
  coe_injective' M N := by simp_all

-- Try to avoid introducing `z.1` and `z.2`.
-- @[simp]
-- lemma val_apply (z : ZHat) (n : ‚Ñï+) : z.1 n = z n := rfl

lemma prop (z : ZHat) (D N : ‚Ñï+) (h : (D : ‚Ñï) ‚à£ N) : ZMod.castHom h (ZMod D) (z N) = z D := z.2 ..

@[ext]
lemma ext (x y : ZHat) (h : ‚àÄ n : ‚Ñï+, x n = y n) : x = y := by
  cases x
  cases y
  congr
  ext n
  apply h

lemma ext_iff (x y : ZHat) : (‚àÄ n : ‚Ñï+, x n = y n) ‚Üî x = y :=
  ‚ü®ext x y, fun h n => by exact congrFun (congrArg DFunLike.coe h) n‚ü©

@[simp] lemma zero_val (n : ‚Ñï+) : (0 : ZHat) n = 0 := rfl
@[simp] lemma one_val (n : ‚Ñï+) : (1 : ZHat) n = 1 := rfl
@[simp] lemma ofNat_val (m : ‚Ñï) [m.AtLeastTwo] (n : ‚Ñï+) :
  (OfNat.ofNat m : ZHat) n = (OfNat.ofNat m : ZMod n) := rfl
@[simp] lemma natCast_val (m : ‚Ñï) (n : ‚Ñï+) : (m : ZHat) n = (m : ZMod n) := rfl

instance commRing : CommRing ZHat := inferInstance

--wooah, `import Mathlib` breaks this. TODO test this again after bump to Lean v4.8
lemma zeroNeOne : (0 : ZHat) ‚â† 1 := by
  intro h
  have h2 : (0 : ZHat) 2 = (1 : ZHat) 2 := by simp [h]
  rw [zero_val, one_val] at h2
  revert h2 ; decide

instance nontrivial : Nontrivial ZHat := ‚ü®0, 1, zeroNeOne‚ü©

instance charZero : CharZero ZHat := ‚ü® fun a b h ‚Ü¶ by
  rw [‚Üê ext_iff] at h
  specialize h ‚ü®_, (max a b).succ_pos‚ü©
  apply_fun ZMod.val at h
  rwa [natCast_val, ZMod.val_cast_of_lt, natCast_val, ZMod.val_cast_of_lt] at h
  ¬∑ simp [Nat.succ_eq_add_one, Nat.lt_add_one_iff]
  ¬∑ simp [Nat.succ_eq_add_one, Nat.lt_add_one_iff]
  ‚ü©
--lemma NonAssocSemiring.Nontrivial_iff (R : Type) [NonAssocSemiring R] :
--    Nontrivial R ‚Üî (0 : R) ‚â† 1 :=
--  ‚ü®fun _ ‚Ü¶ zero_ne_one' R, fun a ‚Ü¶ ‚ü®0, 1, a‚ü©‚ü©

open BigOperators Nat Finset in
/-- A nonarchimedean analogue $0! + 1! + 2! + \cdots$ of $e=1/0! + 1/1! + 1/2! + \cdots$. -/
def e : ZHat := ‚ü®fun (n : ‚Ñï+) ‚Ü¶ ‚àë i in range (n : ‚Ñï), i !, by
  intros D N hDN
  dsimp only
  obtain ‚ü®k, hk‚ü© := exists_add_of_le <| le_of_dvd N.pos hDN
  simp_rw [map_sum, map_natCast, hk, sum_range_add, add_right_eq_self]
  refine sum_eq_zero (fun i _ => ?_)
  rw [ZMod.natCast_zmod_eq_zero_iff_dvd]
  exact Nat.dvd_factorial D.pos le_self_add
‚ü©

open BigOperators Nat Finset in
lemma e_def (n : ‚Ñï+) : e n = ‚àë i in range (n : ‚Ñï), (i ! : ZMod n) := rfl

/-- Nonarchimedean $e$ is not an integer. -/
lemma e_not_in_Int : ‚àÄ a : ‚Ñ§, e ‚â† a := sorry
-- This isn't necessary but isn't too hard to prove.

lemma torsionfree_aux (a b : ‚Ñï) [NeZero b] (h : a ‚à£ b) (x : ZMod b) (hx : a ‚à£ x.val) :
    ZMod.castHom h (ZMod a) x = 0 := by
  rw [ZMod.castHom_apply, ZMod.cast_eq_val]
  obtain ‚ü®y, hy‚ü© := hx
  rw [hy]
  simp

-- ZHat is torsion-free. LaTeX proof in the notes.
lemma torsionfree (N : ‚Ñï+) : Function.Injective (fun z : ZHat ‚Ü¶ N * z) := by
  rw [‚Üê AddMonoidHom.coe_mulLeft, injective_iff_map_eq_zero]
  intro a ha
  rw [AddMonoidHom.coe_mulLeft] at ha
  rw [‚Üê ext_iff]
  intro j
  rw [zero_val, ‚Üê a.prop j (N * j) (by simp)]
  apply torsionfree_aux
  apply Nat.dvd_of_mul_dvd_mul_left N.pos
  rw [‚Üê PNat.mul_coe]
  apply Nat.dvd_of_mod_eq_zero
  have : N * a (N * j) = 0 := by
    have : ((N : ZHat) * a) (N * j) = 0 := by simp [ha]
    exact this -- missing lemma
  simpa only [ZMod.val_mul, ZMod.val_natCast, Nat.mod_mul_mod, ZMod.val_zero] using congrArg ZMod.val this

lemma y_mul_N_eq_z (N : ‚Ñï+) (z : ZHat) (hz : z N = 0) (j : ‚Ñï+) :
    N * ((z (N * j)).val / (N : ‚Ñï) : ZMod j) = z j := by
  have hhj := z.prop N (N * j) (by simp only [PNat.mul_coe, dvd_mul_right])
  rw [hz, ZMod.castHom_apply, ZMod.cast_eq_val, ZMod.natCast_zmod_eq_zero_iff_dvd] at hhj
  rw [‚Üê Nat.cast_mul, mul_comm, Nat.div_mul_cancel hhj]
  have hhj' := z.prop j (N * j) (by simp only [PNat.mul_coe, dvd_mul_left])
  rw [‚Üê hhj']
  rw [ZMod.castHom_apply, ZMod.cast_eq_val]

-- LaTeX proof in the notes.
lemma multiples (N : ‚Ñï+) (z : ZHat) : (‚àÉ (y : ZHat), N * y = z) ‚Üî z N = 0 := by
  constructor
  ¬∑ intro ‚ü®y, hy‚ü©
    rw [‚Üê hy]
    change N * (y N) = 0
    simp [ZMod.natCast_self]
  ¬∑ intro h
    let y : ZHat := {
      val := fun j ‚Ü¶ (z (N * j)).val / (N : ‚Ñï)
      property := by
        intro j k hjk
        have hj := z.prop N (N * j) (by simp only [PNat.mul_coe, dvd_mul_right])
        have hk := z.prop N (N * k) (by simp only [PNat.mul_coe, dvd_mul_right])
        rw [h, ZMod.castHom_apply, ZMod.cast_eq_val, ZMod.natCast_zmod_eq_zero_iff_dvd] at hj
        rw [h, ZMod.castHom_apply, ZMod.cast_eq_val, ZMod.natCast_zmod_eq_zero_iff_dvd] at hk
        have hNjk := z.prop (N * j) (N * k) (mul_dvd_mul (dvd_refl _) hjk)
        rw [ZMod.castHom_apply, ZMod.cast_eq_val] at hNjk
        simp only [PNat.mul_coe, map_natCast, ZMod.natCast_val, ZMod.eq_iff_modEq_nat]
        apply Nat.ModEq.mul_right_cancel' (c := N) (by simp)
        rw [Nat.div_mul_cancel hj, Nat.div_mul_cancel hk,
          mul_comm (j : ‚Ñï) (N : ‚Ñï), ‚Üê ZMod.eq_iff_modEq_nat, hNjk]
        simp
    }
    refine ‚ü®y, ?_‚ü©
    ext j
    exact y_mul_N_eq_z N z h j


end ZHat

open scoped TensorProduct in
/-- The "profinite completion" of ‚Ñö is defined to be `‚Ñö ‚äó ZHat`, with `ZHat` the profinite
completion of `‚Ñ§`. -/
abbrev QHat := ‚Ñö ‚äó[‚Ñ§] ZHat

noncomputable example : QHat := (22 / 7) ‚äó‚Çú ZHat.e

namespace QHat

lemma canonicalForm (z : QHat) : ‚àÉ (N : ‚Ñï+) (z' : ZHat), z = (1 / N : ‚Ñö) ‚äó‚Çú z' := by
  induction z using TensorProduct.induction_on with
  | zero =>
    refine ‚ü®1, 0, ?_‚ü©
    simp
  | tmul q z =>
    refine ‚ü®‚ü®q.den, q.den_pos ‚ü©, q.num * z, ?_‚ü©
    simp only [‚Üê zsmul_eq_mul, TensorProduct.tmul_smul]
    simp only [PNat.mk_coe, zsmul_eq_mul]
    congr
    ¬∑ simp only [‚Üê q.mul_den_eq_num, LinearMap.mul_apply', mul_assoc,
        one_div, ne_eq, Nat.cast_eq_zero, Rat.den_ne_zero, not_false_eq_true,
        mul_inv_cancel, mul_one]
    ¬∑ simp
  | add x y hx hy =>
    obtain ‚ü®N‚ÇÅ, z‚ÇÅ, rfl‚ü© := hx
    obtain ‚ü®N‚ÇÇ, z‚ÇÇ, rfl‚ü© := hy
    refine ‚ü®N‚ÇÅ * N‚ÇÇ, (N‚ÇÅ : ‚Ñ§) * z‚ÇÇ + (N‚ÇÇ : ‚Ñ§) * z‚ÇÅ, ?_‚ü©
    simp only [TensorProduct.tmul_add, ‚Üê zsmul_eq_mul,
      TensorProduct.tmul_smul, TensorProduct.smul_tmul']
    simp only [one_div, PNat.mul_coe, Nat.cast_mul, mul_inv_rev, zsmul_eq_mul, Int.cast_natCast,
      ne_eq, Nat.cast_eq_zero, PNat.ne_zero, not_false_eq_true, mul_inv_cancel_left‚ÇÄ]
    rw [add_comm]
    congr
    simp [mul_comm]

def IsCoprime (N : ‚Ñï+) (z : ZHat) : Prop := IsUnit (z N)

lemma lowestTerms (x : QHat) : (‚àÉ N z, IsCoprime N z ‚àß x = (1 / N : ‚Ñö) ‚äó‚Çú z) ‚àß
    (‚àÄ N‚ÇÅ N‚ÇÇ z‚ÇÅ z‚ÇÇ,
    IsCoprime N‚ÇÅ z‚ÇÅ ‚àß IsCoprime N‚ÇÇ z‚ÇÇ ‚àß (1 / N‚ÇÅ : ‚Ñö) ‚äó‚Çú z‚ÇÅ = (1 / N‚ÇÇ : ‚Ñö) ‚äó‚Çú[‚Ñ§] z‚ÇÇ ‚Üí
      N‚ÇÅ = N‚ÇÇ ‚àß z‚ÇÅ = z‚ÇÇ) := sorry

noncomputable abbrev i‚ÇÅ : ‚Ñö ‚Üí‚Çê[‚Ñ§] QHat := Algebra.TensorProduct.includeLeft
lemma injective_rat :
    Function.Injective i‚ÇÅ := sorry -- flatness

noncomputable abbrev i‚ÇÇ : ZHat ‚Üí‚Çê[‚Ñ§] QHat := Algebra.TensorProduct.includeRight
lemma injective_zHat :
    Function.Injective i‚ÇÇ := sorry -- flatness

section additive_structure_of_QHat

noncomputable abbrev ratsub : AddSubgroup QHat :=
    (i‚ÇÅ : ‚Ñö ‚Üí+ QHat).range

noncomputable abbrev zHatsub : AddSubgroup QHat :=
    (i‚ÇÇ : ZHat ‚Üí+ QHat).range

noncomputable abbrev zsub : AddSubgroup QHat :=
  (Int.castRingHom QHat : ‚Ñ§ ‚Üí+ QHat).range

lemma rat_meet_zHat : ratsub ‚äì zHatsub = zsub := sorry

lemma rat_join_zHat : ratsub ‚äî zHatsub = ‚ä§ := sorry

end additive_structure_of_QHat

section multiplicative_structure_of_QHat

noncomputable abbrev unitsratsub : Subgroup QHatÀ£ :=
  (Units.map (i‚ÇÅ : ‚Ñö ‚Üí* QHat)).range

noncomputable abbrev unitszHatsub : Subgroup QHatÀ£ :=
  (Units.map (i‚ÇÇ : ZHat ‚Üí* QHat)).range

noncomputable abbrev unitszsub : Subgroup QHatÀ£ :=
  (Units.map (Int.castRingHom QHat : ‚Ñ§ ‚Üí* QHat)).range

lemma unitsrat_meet_unitszHat : unitsratsub ‚äì unitszHatsub = unitszsub := sorry

-- this needs that ‚Ñ§ is a PID.
lemma unitsrat_join_unitszHat : unitsratsub ‚äî unitszHatsub = ‚ä§ := sorry

end multiplicative_structure_of_QHat

end QHat

structure Hurwitz : Type where
  re : ‚Ñ§ -- 1
  im_o : ‚Ñ§ -- œâ
  im_i : ‚Ñ§ -- i
  im_oi : ‚Ñ§ -- œâi -- note iœâ + œâi + 1 + i = 0

notation "ùìû" => Hurwitz -- ùìû = \MCO
namespace Hurwitz

lemma ext (z w : ùìû) (h_re : z.re = w.re) (h_im_o : z.im_o = w.im_o)
    (h_im_i : z.im_i = w.im_i) (h_im_oi : z.im_oi = w.im_oi) : z = w :=
  by cases z; cases w; congr;

/-! ## zero (0) -/

/-- The Hurwitz number 0 -/
def zero : ùìû := ‚ü®0, 0, 0, 0‚ü©

/-- notation `0` for `zero` -/
instance : Zero ùìû := ‚ü®zero‚ü©

@[simp] lemma zero_re : re (0 : ùìû) = 0 := rfl
@[simp] lemma zero_im_o : im_o (0 : ùìû) = 0 := rfl
@[simp] lemma zero_im_i : im_i (0 : ùìû) = 0 := rfl
@[simp] lemma zero_im_oi : im_oi (0 : ùìû) = 0 := rfl

/-! ## one (1) -/

def one : ùìû := ‚ü®1, 0, 0, 0‚ü©

/-- Notation `1` for `one` -/
instance : One ùìû := ‚ü®one‚ü©

@[simp] lemma one_re : re (1 : ùìû) = 1 := rfl
@[simp] lemma one_im_o : im_o (1 : ùìû) = 0 := rfl
@[simp] lemma one_im_i : im_i (1 : ùìû) = 0 := rfl
@[simp] lemma one_im_oi : im_oi (1 : ùìû) = 0 := rfl

/-! ## Neg (-) -/

-- negation

/-- The negation `-z` of a Hurwitz number -/
def neg (z : ùìû) : ùìû := ‚ü®-re z, -im_o z, -im_i z, -im_oi z‚ü©

/-- Notation `-` for negation -/
instance : Neg ùìû := ‚ü®neg‚ü©

-- how neg interacts with re and im_*
@[simp] lemma neg_re (z : ùìû) : re (-z) = -re z  := rfl
@[simp] lemma neg_im_o (z : ùìû) : im_o (-z) = -im_o z  := rfl
@[simp] lemma neg_im_i (z : ùìû) : im_i (-z) = -im_i z  := rfl
@[simp] lemma neg_im_oi (z : ùìû) : im_oi (-z) = -im_oi z  := rfl

/-! ## add (+) -/

-- Now let's define addition

/-- addition `z+w` of complex numbers -/
def add (z w : ùìû) : ùìû := ‚ü®z.re + w.re, z.im_o + w.im_o, z.im_i + w.im_i, z.im_oi + w.im_oi‚ü©

/-- Notation `+` for addition -/
instance : Add ùìû := ‚ü®add‚ü©

-- basic properties
@[simp] lemma add_re (z w : ùìû) : re (z + w) = re z  + re w  := rfl
@[simp] lemma add_im_o (z w : ùìû) : im_o (z + w) = im_o z  + im_o w  := rfl
@[simp] lemma add_im_i (z w : ùìû) : im_i (z + w) = im_i z  + im_i w  := rfl
@[simp] lemma add_im_oi (z w : ùìû) : im_oi (z + w) = im_oi z  + im_oi w  := rfl

instance : AddCommGroup ùìû where
  add_assoc := by intros; apply ext <;> simp [add_assoc]
  zero_add := by intros; apply ext <;> simp
  add_zero := by intros; apply ext <;> simp
  nsmul := nsmulRec
  zsmul := zsmulRec
  add_left_neg := by intros; apply ext <;> simp
  add_comm := by intros; apply ext <;> simp [add_comm]

/-! ## mul (*) -/

-- multiplication

/-- Multiplication `z*w` of two Hurwitz numbers -/
def mul (z w : ùìû) : ùìû :=
  ‚ü®z.re * w.re + sorry, sorry, sorry, sorry‚ü©

/-- Notation `*` for multiplication -/
instance : Mul ùìû := ‚ü®mul‚ü©

-- how `mul` reacts with `re` and `im`
@[simp] lemma mul_re (z w : ùìû) : re (z * w) = re z * re w + sorry := rfl

-- @[simp] lemma mul_im_0 (z w : ùìû) : sorry := rfl etc etc

instance ring : Ring ùìû := { (inferInstance : AddCommGroup ùìû) with
  left_distrib := sorry
  right_distrib := sorry
  zero_mul := sorry
  mul_zero := sorry
  mul_assoc := sorry
  one_mul := sorry
  mul_one := sorry
}

/-- Conjugate; sends $a+bi+cj+dk$ to $a-bi-cj-dk$. -/
def conj : ùìû ‚Üí‚Çê[‚Ñ§] ùìû where
  toFun z := ‚ü®z.re -z.im_o, -z.im_o, -z.im_i, -z.im_oi‚ü© -- not right but something like this
  map_one' := sorry
  map_mul' := sorry
  map_zero' := sorry
  map_add' := sorry
  commutes' := sorry

def norm : ùìû ‚Üí ‚Ñ§
| mk a b c d => sorry -- not a*a + b*b + c*c + d*d because of œâ

lemma norm_eq_mul_conj (z : ùìû) : (norm z : ùìû) = z * conj z := sorry

lemma norm_zero : norm 0 = 0 := sorry

lemma norm_one : norm 1 = 1 := sorry

lemma norm_mul (x y : ùìû) : norm (x * y) = norm x * norm y := sorry

lemma norm_nonneg (x : ùìû) : 0 ‚â§ norm x := sorry

lemma norm_eq_zero (x : ùìû) : norm x = 0 ‚Üî x = 0 := sorry

lemma quot_rem (a b : ùìû) (hb : b ‚â† 0) : ‚àÉ q r : ùìû, a = q * b + r ‚àß norm r < norm b := sorry

lemma left_ideal_princ (I : Submodule ùìû ùìû) : ‚àÉ a : ùìû, I = Submodule.span ùìû {a} := sorry

open scoped TensorProduct

noncomputable def HurwitzHat : Type := ùìû ‚äó[‚Ñ§] ZHat

notation "ùìû^" => HurwitzHat

noncomputable instance : Ring ùìû^ := Algebra.TensorProduct.instRing

noncomputable def HurwitzRat : Type := ‚Ñö ‚äó[‚Ñ§] ùìû

notation "D" => HurwitzRat

noncomputable instance : Ring D := Algebra.TensorProduct.instRing

noncomputable def HurwitzRatHat : Type := D ‚äó[‚Ñ§] ZHat

notation "D^" => HurwitzRatHat

noncomputable instance : Ring D^ := Algebra.TensorProduct.instRing

noncomputable abbrev j‚ÇÅ : D ‚Üí‚Çê[‚Ñ§] D^ := Algebra.TensorProduct.includeLeft -- (Algebra.TensorProduct.assoc ‚Ñ§ ‚Ñö ùìû ZHat).symm.trans Algebra.TensorProduct.includeLeft

lemma injective_hRat :
    Function.Injective j‚ÇÅ := sorry -- flatness

noncomputable abbrev j‚ÇÇ : ùìû^ ‚Üí‚Çê[‚Ñ§] D^ :=
  ((Algebra.TensorProduct.assoc ‚Ñ§ ‚Ñö ùìû ZHat).symm : ‚Ñö ‚äó ùìû^ ‚âÉ‚Çê[‚Ñ§] D ‚äó ZHat).toAlgHom.comp
  (Algebra.TensorProduct.includeRight : ùìû^ ‚Üí‚Çê[‚Ñ§] ‚Ñö ‚äó ùìû^)

lemma injective_zHat :
    Function.Injective j‚ÇÇ := sorry -- flatness

-- should I rearrange tensors? Not sure if D^ should be (‚Ñö ‚äó ùìû) ‚äó ‚Ñ§hat or ‚Ñö ‚äó (ùìû ‚äó Zhat)
lemma canonicalForm (z : D^) : ‚àÉ (N : ‚Ñï+) (z' : ùìû^), z = j‚ÇÅ ((N‚Åª¬π : ‚Ñö) ‚äó‚Çú 1 : D) * j‚ÇÇ z' := by
  sorry

lemma completed_units (z : D^À£) : ‚àÉ (u : DÀ£) (v : ùìû^À£), (z : D^) = j‚ÇÅ u * j‚ÇÇ v := sorry

end Hurwitz
